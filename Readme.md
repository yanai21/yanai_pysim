# 手法１
## 優先目的関数
1. 計算損失を発生させない
2. 緊急ジョブを即時実行

## 前提条件
- 通常ジョブの実行終了時刻は不明
- 緊急ジョブのノード数は固定
- 緊急ジョブの使用メモリ使用量はわかる
- 通常ジョブの使用メモリ使用量はわかる
- PPSの値もわかる

## アルゴリズム
1. Idleノードに割り当てる
2. 足りない場合  (for i in range(1,足りないノード))
    ### dpとnode起動  
    1. どちらも値があるならば、dpとnode起動のテーブル比較し、小さいほうを採用  
    2. ノード起動しか値がない場合は、次にあるdpまで飛び比較  
        - 起きる場合  
            - 中断のみ発生  
            - node起動のみ発生
            - node起動と中断が発生
    #### プログラムの動き
    1. 選択
        - どちらも値があるならば、dpとnode起動のテーブル比較し、小さいほうを採用  
        - ノード起動しか値がない場合は、次にあるdpまで飛び比較  
    2. 実行 (ノード数を指定で実行,eventをlistで管理)
        - 中断のみ
            - ジョブを中断
            - 中断したノードで実行
            - ジョブを再開
        - ノード起動のみ
            - ノードを起動
            - 実行
            - ノードをシャットダウン
        - 中断とノード起動
    ### dpのみある
    - dpで採用
    ### node起動のみ
    - 即時実行ならば、ノード起動よりも計算損失量が小さいならば強制終了？ (比較は計算損失量 or 残りの実行時間？)
    - メイクスパンならば、ノード起動？
    ### どちらもない
    - 計算損失が小さい順で強制終了？

### 評価指標
- システム全体のメイクスパン
- 消費電力

### 評価対象
- 中断を最優先
- ノード起動を最優先
#### 実装
- 変わるのは、urgentAssigmentのみ
- 一度に全ての結果がとれるようにしたいよね…


### 手法2
### 優先目的関数
1. 緊急ジョブを締切内で実行


### 前提条件
- 通常ジョブの実行時間予測はできない
- 緊急ジョブのノード数は固定
- 緊急ジョブの使用メモリ使用量はわかる
- 通常ジョブの使用メモリ使用量はわかる
- PPSの値もわかる
### アルゴリズム
1. 



